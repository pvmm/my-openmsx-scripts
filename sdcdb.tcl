# SDCDB connector - Version 1.0
#
# Copyright 2025 Pedro de Medeiros all rights reserved
#
# SDCDB connector uses SDCC integrated debugger to create breakpoints and much more.
#
# The main difference between SDCDB connector's breakpoints and the built-in OpenMSX
# breakpoints is the C code integration:
# [*] allow users to create breakpoints on C code:
#     > sdcdb::break main.c:55
# [*] list C source code at line 100:
#     > sdcdb::list main.c:100
# [*] and more things to come (WIP).
# 
# Caveat: you need the sdcdb debugger and sz80 simulator (µCsim) from the SDCC compiler
# collection to run SDCDB connector. Some package managers rename sz80 to ucsim_z80, so
# sdcdb won't work without renaming it or creating a symlink to sz80.
#
# Commands that SDCDB connector recognizes directly. You may call them with sdcdb::[COMMAND] [ARGS...]:
#
# select path
#       - Set path to the debugger program binary.
# connect ?src? path
#       - Invoke SDCDB and connect to it. You may specify paths to the source files that SDCDB
#         uses (colon-separated list of paths). Path points to the directory containg the IHX
#         (NAME.ihx) and CDB (NAME.cdb) files generated by SDCC (compile your code using SDCC
#         -debug parameter).
# disconnect
#       - close connection to SDCDB, killing the process.
# break line
#       - creates breakpoint in [LINE | FILE:LINE | *<address>]
# list ?line?
#       - list source code at [LINE | FILE:LINE | *<address>]
# ucsim [COMMAND]
#       - invoke µCsim command directly
#
# For more information about SDCDB: https://sourceforge.net/p/sdcc/wiki/Home/
# For more information about µCsim: https://www.ucsim.hu/

namespace eval sdcdb {

variable ucsim   {}
variable target  {}
variable pipe    0
variable sdcdb   sdcdb  ;# path to sdcdb
variable message ""
variable context none
variable srcpath .
variable context {}
variable command        ;# last command sent to debugger
variable empty   0      ;# last response was empty?

set_help_proc sdcdb [namespace code sdcdb_help]
proc sdcdb_help {args} {
        if {[llength $args] == 1} {
                return {The sdcdb connector script connects OpenMSX to the SDCC debugger.
Recognized commands: select, connect, disconnect, break, list, ucsim
}
        }
        switch -- [lindex $args 1] {
                "select" { return {Define location of the SDCDB program when not found in the PATH.

Syntax: sdcdb select path
}}
                "connect" { return {Connects to the SDCDB debugger.

Syntax: sdcdb connect ?src? target

src is a list of directories where SDCDB looks for source code. target is the location of the IHX file created by SDCC and compiled with the -debug parameter.
}}
                "disconnect" { return {Disconnects and kill the SDCDB debugger.

Syntax: sdcdb disconnect
}}
                "break" { return {Creates a breakpoint.

Syntax: sdcdb break file:line

file:line where the breakpoint will be created.
}}
                "list" { return {Lists contents of a source code file.

Syntax: sdcdb list file:line
}}
}
}

proc output {args} {
    set chan stdout
    if {[llength $args] == 1} {
        puts $chan [lindex $args 0]
    } else {
        puts [lindex $args 0] $chan [lindex $args 1]
    }
    flush $chan
}

proc warn {msg} {
    if {[env DEBUG] ne 0} {
        set chan stderr
        set msg [string map {"\n" "\\n"} $msg]
        puts $chan $msg
        flush $chan
    }
}

proc env {varname {defaults {}}} {
        if {[info exists ::env($varname)]} {
                return $::env($varname);
        }
        return $defaults;
}

proc sdcdb {args} {
    if {[env DEBUG] ne 0} {
        if {[catch {dispatcher {*}$args} fid]} {
            puts stderr $::errorInfo
            error $::errorInfo
        }
    } else {
        dispatcher {*}$args
    }
    return
}

proc dispatcher {args} {
    set params "[lrange $args 1 end]"
    switch -- [lindex $args 0] {
        "select"    { return [sdcdb_select  {*}$params] }
        "connect"   { return [sdcdb_connect {*}$params] }
        "break"     { return [sdcdb_break   {*}$params] }
        "list"      { return [sdcdb_list    {*}$params] }
        "ucsim"     { return [sdcdb_ucsim   {*}$params] }
        "sc"        { return [sdcdb_sc      {*}$params] }
        default     { error "Unknown command \"[lindex $args 0]\"." }
    }
}

proc sdcdb_select {p} {
    variable sdcdb
    if {[is_in_path $p] eq 0} {
        error "SDCDB not a file or file not found"
    }
    set sdcdb $p
}

proc is_in_path {program} {
    foreach dir [split $::env(PATH) ":"] {
        if {[file executable [file join $dir $program]]} {
            if {[file isfile $program]} { return 1 }
        }
    }
    return 0
}

proc sdcdb_connect {args} {
    variable sdcdb
    sdcdb_select $sdcdb
    output "Opening SDCDB process..."
    variable pipe
    if {[llength $args] == 1} {
        set target [lindex $args 0]
    } elseif {[llength $args] == 2} {
        set srcpath [lindex $args 0]
        set target [lindex $args 1]
    } else {
        error "wrong # args: should be connect ?src? target"
    }
    variable command [list $sdcdb -v -mz80 --directory=$srcpath -z -b $target]
    warn "command: $command"
    variable context connection
    set pipe [open |$command [list RDWR NONBLOCK]]
    fconfigure $pipe -blocking 0 -buffering line
    fileevent $pipe readable [list sdcdb::handle_output]
}

proc handle_output {} {
    variable pipe
    if {[eof $pipe]} {
        output "SDCDB process died."
        fileevent $pipe readable {}
        close $pipe
        variable pipe 0
        return
    }
    set response [read $pipe]
    set response [string trimright $response "(sdcdb) "]
    set response [string trimright $response "\n"]
    variable empty
    variable command
    if {$response ne {}} {
        warn "response: {$response}"
        set empty 0
    } elseif {$response eq $command} {
        warn "response: *repeat*"
        return
    } elseif {$empty eq 0} {
        warn "response: *empty*"
        incr empty
    }
    variable context
    warn "context is $context"
    switch -- $context {
        connection {
            set pattern {file (\S+)}
            set matches [regexp -inline $pattern $response]
            if {[llength $matches] > 0} {
                variable target [lindex $matches 1]
                output "$target target found"
            }
            # {\+ (\S+) -P -r 9756}
            set pattern {\+ (\S+)}
            set matches [regexp -inline $pattern $response]
            if {[llength $matches] > 0} {
                variable sdcdb
                variable ucsim [lindex $matches 1]
                warn "$ucsim simulator expected."
                set path [file dirname $sdcdb]
                if {![file executable [file join $path $ucsim]]} {
                    error "$ucsim simulator not found"
                } else {
                    output "$ucsim simulator found"
                }
            }
        }
        break0 {
            # Breakpoint <n> at 0x<address>: file <file>.c, line <line>.
            #set pattern {Breakpoint (\d+) at 0x(\w+): file (\S+), line (\d+).}
            #set matches [regexp -inline $pattern $response]
            set context break1
            send_command "info break"
        }
        break1 {
            # Num Type           Disp Enb Address    What
            # 1   breakpoint     keep y   0x0000480d at main.c:52
            set pattern {(\d+)\s+(\S+)\s+(\S+)\s(\S)\s+0x(\S+) at ([^:]+):(\d+)}
            set matches [regexp -inline $pattern $response]
            if {[llength $matches] > 0} {
                set bpnum   [lindex $matches 1]
                set address [lindex $matches 5]
                set file    [lindex $matches 6]
                set line    [lindex $matches 7]
                output "[debug set_bp "0x$address"]: breakpoint at 0x$address"
            } else {
                error "Parse error: breakpoint not found"
            }
            set context break2
            send_command "d$bpnum"
        }
        break2 {
            set pattern {Deleted breakpoint (\d+)}
            set matches [regexp -inline $pattern $response]
            if {![llength $matches]} {
                error "Parse error: breakpoint not found"
            }
            set context none
        }
        output {
            if {$response ne {}} {
                output $response
            }
            set context none
        }
        debug {
            if {$response ne {}} {
                warn $response
            }
            set context none
        }
        default {
            set context none
        }
    }
}

proc send_command {cmd} {
    warn "send_command($cmd)"
    variable pipe
    if {$pipe eq 0} {
        error "SDCDB connection not found, call connect first."
    }
    if {[catch {puts $pipe [string trimright $cmd "\n"]; flush $pipe} err]} {
        output "Error sending command: $err"
    }
    variable command $cmd
}

proc sdcdb_disconnect {} {
    variable pipe
    if {$pipe eq 0} {
        error "SDCDB connection not found, call connect first."
    }
    fileevent $pipe readable {}
    close $pipe
    output "SDCDB process closed."
    set pipe 0
}

proc sdcdb_break {arg} {
    set pattern {([^:]+):(\d+)}
    set matches [regexp -inline $pattern $arg]

    if {[llength $matches] > 0} {
        variable context break0
        send_command [list break $arg]
    } else {
        error "error parsing break command"
    }
}

proc sdcdb_list {arg} {
    variable context output
    send_command [list list $arg]
}

proc sdcdb_ucsim {args} {
    variable context output
    send_command ![join $args]
}

# direct access to send_command
proc sdcdb_sc {args} {
    variable context output
    send_command [join $args]
}

namespace export sdcdb
#namespace emsemble create

}

# Import sdcdb exported functions
namespace import sdcdb::*
